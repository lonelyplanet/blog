
After upgrading to Capybara 2 we spent a lot of time giving love to our neglected child. Feature/Acceptance tests. We had a lot of them and it was always the place we spent the least amount of time, we would write a few step definitions and throw in a few Capybara calls but more often than not we would write some javascript to interact with the page.

The reasoning for this is that our app is an offline client-side based up and we couldn't always get Capybara to bend to our will.
The problem was that we would have spurious failures, usually because of timing, to which we would respond with a capybara.wait_until. I believe this was our approach because we didn't understand

With the improvements to Capybara 2 we were able to remove a lot of the old javascript hackery and repalce it with sexy, simple Capybara calls.

I have pulled out a few worthwhile examples of how we are using Capybara instead of javascript to solve the problem :)


###  Expanding a list, deselecting and selecting



```ruby
 Then /^I wait until manifest loads$/ do
-  wait_for_manifest_to_load(Capybara.default_wait_time)
-end
-
-Then /^I wait a long time for the manifest to load$/ do
-  wait_for_manifest_to_load(120)
-end
-
-Then /^I should not see any errors while syncing$/ do
-  first("#sync_error").visible?.should_not == true unless page.evaluate_script %{$("#sync_error").length == 0}
+  assert_selector(".manifest_title .loading.hidden")
 end

 def check_for_selected_manifest manifest_name
-  check_result = %{$("#content_pack_content ul.selected_items .select_manifests[value='#{manifest_name}']").is(":checked");}
-  evaluate_script_and_wait_for_result(check_result, "Timed out. Unable to find #{manifest_name} within selected items")
+  page.has_checked_field?(manifest_name).should be_true, "Unable to find #{manifest_name} within selected items"
 end

 def check_for_selected_place place_name
-  check_result = %{$("#content_pack_content ul.selected_items div.pack_item_label[data-value='#{place_name}']").length == 1;}
-  evaluate_script_and_wait_for_result(check_result, "Timed out. Unable to find #{place_name} within selected items")
+  within "#content_pack_content .content_pack_places ul.selected_items" do
+    page.has_selector?(".pack_item_label[data-value='#{place_name}']").should be_true, "Unable to find `#{place_name}` within selected items"
+  end
 end

 def check_search_results_are_not_visible
   page.assert_selector "#content_pack_content ul.ui-autocomplete", :visible => false
 end

-def evaluate_script_and_wait_for_result script, timed_out_message
-  begin
-    wait_until {page.evaluate_script(script)}
-  rescue TimeoutError => e
-    raise timed_out_message
-  end
-end
-
 def remove_item_from_content_pack(name)
   first('.pack_item_label', :text => name).first(:xpath,".//..").first('.delete_type').click
 end

 def remove_manifest_from_content_pack(name)
-  page.evaluate_script %{!$("input[type='checkbox'].select_manifests[value = '#{name}']").click().is(":checked")}
-end
-
-def wait_for_manifest_to_load(timeout)
-  wait_until(timeout) { first(".manifest_title .loading.hidden") }
+  #Expand manifest list
+  page.find_field(name).first(:xpath, "./ancestor::ul").first(".pack_item_label").click
+  #Uncheck manifest
+  page.uncheck name
+  page
```